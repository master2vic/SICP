# 赋值、状态和副作用(Assignment,State & Side-effects)

## Part 1

之前的程序都是函数式程序，函数式编程就是一种对数学事实的编码。

~~~scheme
<before>
(set! <var> <value>)
<after>
~~~

在整个程序的运行周期中在赋值语句发生之前和赋值语句发生之后是不同的。这就意味着涉及到赋值语句的部分，严格意义上不是函数。因为代换模型不起作用。所以需要一个新的模型。

赋值语句带来的一个弊端就是每个符号不在和其值有关而是和储存这个值的地方有关。

赋值语句会带来很多问题：赋值语句执行时机十分重要，不小心会带来bug。

所以使用赋值语句需要两个前提:
1. 需要一个新的计算模型 
2. 一个非常好的理由支持我们做如此丑恶的事情。

## 思考

set! 和 define 的区别：一个是赋值语句，对已经产生的对象操作，一个是宏定义一个新的对象。而let的作用域是上下文。
~~~scheme
(let ((var1 e1) (var2 e2))
    e3)

=>
((λ(var1 var2)
    e3)
    e1
    e2)
~~~
事实上let就是下面的语法糖，以var1和var2为形参，e3为过程体，e1和var1绑定，e2和var2绑定的一个过程。

## Part2 约束变量（bound variable）

这里可能有点需要离散数学的知识。这一个过程中有自由变量和约束变量的时候，如果把自由变量用另一个变量来代替，那么整个过程就改变了意思。但是如果改变的是全部的约束变量，那么整个过程的意思就不会发生变化。

那么要知道这些变量的作用域，就是lambda后面的过程体。

环境结构（environment structures）就是执行虚拟代换的一种方式是存储未完成的代换的地方。这是一个积累各种东西的地方。在这里，变量的名字与值关联在一起。所以当问这个名字是什么的时候其实就是在环境中找答案。所以环境就是一个函数、或者表（结构化的表）。框架是环境的一部分。 

如下如：

![pic1.png](pic\part2-env.png)
其中A、B、C、D是环境，C和D是相同的环境；Ⅰ、Ⅱ、Ⅲ是框架；z、x是框架Ⅱ中的约束变量

在框架Ⅲ的角度看：y是2，而不是5。这里称框架Ⅲ中的y屏蔽了框架Ⅱ中的y。从环境B的角度去看的时候不只是能看到m、y还能看到x=3.

~~~scheme
(λ(y) (λ(x) (* x y)) 3)
~~~

看这个过程体：在λ(x)中，y是自由变量，x是约束变量。x的值可以通过形参来获得，因为约束变量就在当前的框架中。但是，y的值不在当前的框架中。需要知道y的值，而这里有一个指向当前框架所在环境的指针，那么y就可以在这个环境中寻找。

这里我的个人理解：环境是当前框架所在的地方，环境中可能有其他框架。框架中有约束变量和自由变量。其中自由变量就需要去环境中寻找。

## Part 3

~~~scheme
(define make-counter
    (λ(N)
        (λ()
            (set! N (1+ N))
            N)))
~~~

 