# 复合数据 Compound Data

## 前言

### wishful thinking：按愿望思维的方式。
在我们开始设计一个程序的时候先不考虑每一个用到的函数具体是怎么实现的。我们先假设我们可以直接使用这个函数。

## Part A

关键点：构建一个层次化的系统。

如果先假设有了处理数据类型的`构造过程`和`选择过程`。那么就可以使用这个数据类型做计算。其中选择过程就是从数据类型中得到部分信息的过程。

Lisp 中提供了一种基本运算符 `cons` 用来做这个种构造过程，与之相对应的是`car`和`cdr`分别是选择过程中取出首元素和取出次元素的运算符。

在复合数据上的运算就和符合数据的基础实现之间出现了抽象层。这层抽象层保证我们可以在对复合数据做运算的时候，不需要在意底层究竟是怎么实现的。而构建这个抽象层的就是*构造过程和选择过程*。

方法论：分离对复合数据的使用和对复合数据的表示。而分理层就是构造过程和选择过程。 这种方法论叫做：数据抽象（data abstraction）。

抽象数据的意义：不仅仅为了书写方便，真正更深层次的理由就是：把对符合数据的定义和使用完全分离。在使用的时候完全不需要考虑是怎样的定义就可以使用。因为往往对于一种特性的复合数据的定义可能有很多种，甚至在不同的应用场景中不同的定义方式会有不同的工作效率，但是抽象之后这些都不是顶层设计的需要考虑的，这些是实现底层的时候才需要考察的。

## 课堂问题

### 在抽象层做决定和在编码前做决定，究竟是哪点好？

回答： 在编码前就做好决定绝对是少数人才做的事，而且这些人应该是没有接触过大型项目。

## Part B

闭包：cons可以将两个数值组合为一个`对`(pair)，同是这种组合方式对与对也成立，这种性质称为闭包。

闭包是构建层次化系统的一种重要途径之一。

### `cons`之下

在我们知道了有这种具有神奇魔力的cons之后我们好像就认为cons就是可以做到，但是没有想过cons是什么？

这就是抽象的力量

~~~scheme
(define (cons a b)
    (lambda (pick)
        (cond ((= pick 1) a)
            ((= pick 2) b))))
(define (car x) (x 1))
(define (cdr x) (x 2))
~~~
这就很神奇了，因为之前一直以为cons是类似数组之类的，看到了在cons的内部并没有任何的数据。同时cons抽象出来的数据类型所定义的数据事实上是一个过程，但是这个过程的种种行为看起来真的很像数据。

尤其是把过程当参数传入`car`和`cdr`的时候真的很具有迷惑性，而这种迷惑性来自于较好的封装思路。

举一个例子：
~~~scheme
(car (cons 37 49))

(car (lambda (pick)
    (cond ((= pick 1) 37)
        ((= pick 2) 49))))

(car (lambda (pick)
    (cond ((= pick 1) 37)
        ((= pick 2) 49)))))

(lambda (pick)
    (cond ((= pick 1) 37)
        ((= pick 2) 49)))
1)

(cond ((= 1 1) 37)
    ((= 1 2) 49))

37
~~~

这说明了一个问题：*构建抽象数据结构根本不需要数据*
同时也说明：**数据和过程的边界会越来越模糊**，而模糊这个边界则是十分重要的编程技巧。

### 课堂问题

#### 当我们多次使用cons之后，计算机怎么知道数据是哪个？究竟数据存储在哪里？

过程不是一个执行行为的系列，他还是一个特定的对象。当我们去定义了 A 是一个对之后，那么这个A是一个过程，同时他是一个特定的过程：他的选择操作出的结果是定的。但是cons本身是不定的，你可以用cons本身来定义不同的数对。但是，这些数对本身是相互独立的，而且在没有改变之前这些过程又是确定的。即可以预测他的结果。

#### 在已经定义好了一个数对如 A 是 (cons 37 49),那么当我们再次调用(cons 37 49)的时候究竟有什么区别呢?

这其实就是这门课程一直要讨论的一个问题。这和“(- 2 2) 和 0 有什么区别”这类问题本质上是一类问题。在这门课程中会不断探讨这个问题。