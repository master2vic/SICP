# 模式匹配：基于规则的代换(Pattern-matching:Rule-based Substitution)

## Part 1

![pic](pic\4a-part1.1.png)

### 构建一种语言及其解释和执行方法。

功能：可以直接表示那些表达式和导数规则。

**与其将规则翻译为程序并让计算机执行，不如让计算机理解这些规则。**就是将匹配、实例化还有控制结构等概念从规则中分开并且封装。

~~~scheme
(define deriv-rules
    (
        ( (dd (?c c) (? v))     0)
        ( (dd (?v v) (? v))     1)
        ( (dd (?v u) (? v))     0)

        ( (dd (+ (? x1) (? x2)) (? v))
            (+ (dd (: x1) (: v))
                (dd (: x2) (: v)))          )
        
        ( (dd (* (? x1) (? x2)) (?v))
            (+ (* (: x1) (dd (: x2) (: v)))
            (* (dd (: x1) (: v)) (: x2)))   )
    
    ( (dd (* (? x1) (? x2)) (? v))
        (+ (* (: x1) (dd (: x2) (: v)))
            (* (dd (: x1) (: v)) (: x2)))   )

    ( (dd (** (? x) (?c n)) (? v))
        (* (* (: n)
                (** (: x) (: (- n 1))))
            (dd (: x) (: v)))               )
    ))
~~~

### Pattern match(模式匹配问题)
规则：
1. foo - matches exactly foo (形如foo 这样的符号与其自身匹配)
2. (f a b) - 匹配一个表：首元素是f、第二个元素是a、第三个元素是b。
3. (? x) - 匹配任意表达式，称其为x
4. (?c x) - 只匹配常量。并将匹配的常量成为x
5. (?v x) - 匹配变量。并将匹配的变量称之为x

### skeletons (为实例化准备骨架)
1. foo - 实例化为 foo
2. (f a b) - 实例化为三元素表，其元素分别为f、a、b各自实例化的结果
3. (: x) - 实例化为x的值

所以看上面的程序，这些都是对象。

通用化简器(simplifier)：将求导规则送入化简器从而产生dsimp
~~~scheme
(define dsimp
    (simplifier deriv-rule))
~~~

问题：在宏观上要做什么？这些规则是如何运作的？减缓程序是如何使用这些规则来输入表达式并返回一个合理的答案？

![pic](pic\4a-part1.2.png)

在每个规则中都有模式和骨架，把一些列的模式变量从匹配器传递到实例化器中(传递的东西叫字典，如：x匹配下列表达式，而y则匹配另外某些表达式等)。同样的实例化器也会传递表达式给匹配器。规则对应的模式传送进匹配器，对应的骨架送进实例化器中。

这样一个有机结构会这样对一个表达式操作：考察表达式的所有子表达式，给定一个表达式，这些规则被不断应用。首先，对于传入的表达式的每一个子表达式。所有的规则都会考察一次。如果有规则匹配成功，那么就会执行这个过程(传递一本储存值的词典，实例化器产生一个新的表达式，该表达式基本上只是替换了原表达式中的匹配部分)。然后，对这个子表达式重新检测，看看表达式可不可以被简化。再然后，对每一个表达式这样做，直到没有任何变化

### 问题
#### 1 . 匹配器和实例化器式两个独立的程序吗？
他们被分成很多小块，然后在更大的结构中组合起来。

(在实例化器中，发生的不是表达式的改变，而是从新生成了一个新的表达式)

(Tip : 这节中的匹配模式很像一种叫做Porlog的语言。这种语言是专门为处理逻辑问题而生的。)

## Part 2

 