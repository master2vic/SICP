# 计算过程

在开始学习的时候，要明确一点：**在试图理解一个复杂系统的时候不要过度纠结与细节，因为要避免不必要的注意、计算和思考。这也就是为什么抽象这么重要！**

> The key to understanding complicated things is to know what not to look at and what not to compute and what not to think.

> if you have the name of a spirit, you have power over it.
在学习的时候一定要记住一些名词，因为之后知道了这些名词，你才知道如何去表达。

## 一个例子

皮亚诺算法定义的加法：
~~~scheme
(define (+ x y)
    (if (= x 0)
        y
        (+ (-1+ x) (1+ y))))
~~~
这又是一个递归，此消彼长，直至一个为零，这样就完成了加法过程。

其中'-1+'和'1+'都是更基本过程。

## Text Section

在学习计算机的时候要培养一种直觉：程序是如何演变为计算过程的。

对比两种加法：
~~~scheme
(define (+ x y)
    (if (= x 0)
        y
        (+ (-1+ x) (1+ y))))

(define (+ x y)
    (if (= x 0)
        y
        (1+ (+ (-1+ x) y))))
~~~
这两种方式都是利用了此消彼长的原理。对一个减一另一个加1，但是区别在于减一和加一的时机不同。

为了看到这样的区别会带来什么结果：我们来看这两个程序的不同计算过程.以3+5为例

~~~scheme
1. 
(+ 3 5) =>
(+ 2 6) => 
(+ 1 7) => 
(+ 0 8) => 
8

2. 
(+ 3 5) => 
(1+ (+ 2 5)) => 
(1+ (1+ (+ 1 5))) => 
(1+ (1+ (1+ (+ 0 5)))) => 
(1+ (1+ (1+ 5))) => 
(1+ (1+ 6)) => 
(1+ 7) => 
8
~~~
这两个过程有非常明显的不同的计算过程，这两种计算过程的形状十分的不同。要培养的就是对不同计算过程“形状”的感觉，就像一个 **“魔法师”** 一样。

那么这两个计算过程的形状不同说明了什么呢？

方法一: 可以看到计算的次数与计算中参数x一致，即time = O(x)。时间复杂度为O(x)。同时也看到不论计算到哪一步，计算机需要保存的只有那几个元素，且与x无关。即空间复杂度度space = O(1)

方法二：可以看到计算的次数是x的一次函数，所以时间复杂度为time = O(x)。但是空间复杂度则不同。因为在这里在一开始x>0时每一次计算都要保存多一点，因为要加的1此刻还没有加上。所以空间复杂度space = O(x)。


这两种过程分别有一个相对应的名称:迭代(Iterative)，递归(recursive)。在这里更缺的说分别是：线性迭代和线性递归过程。但是更有趣的是这两种计算过程都是用递归定义的。

#### 进一步体会递归过程

在数学中有一个斐波那契数列，就是每一项是前两项的和。
~~~ scheme
0 1 2 3 4 5 6 7  8 ...
0 1 1 2 3 5 8 13 21...
~~~

这个数列中包含了两个基本规则：
1. 第0项和第1项是本身。
2. 其他项为前两项之和。
根据这两个规则可以写出非常简单的程序。能够给定一个特定的N(N > 0)求出其对应的第N项数的值。
~~~scheme
(define (fib n)
    (+ (fib (-1+ n)
        (fib (- n 2)))))
~~~
这样就定义好了一个斐波那契数列的函数。

下面来看一下这个函数所形成的计算过程用一颗树来表示的时候，会长成什么样子。（以求N = 4为例）

![fib 4.png](pic\fib4.png)

可以看到这个计算过程是很糟糕的，因为其中对第2个数进行了两次计算，**代价是计算整个以2为跟节点的树**。同时还有一个仅仅看树会忽略的问题：**不论计算到哪一个子节点，都要保存其上面的计算路径，因为要求和。同时还要保存有哪些节点没有计算**。所以这会带泪很大的空间浪费。

同样的问题在汉诺塔问题上也会有所体现。

~~~ scheme

(define (move n from to spare)
    (cond ((= n 0) "done")
        (else
        (move (-1+ n) from spare to)
        (print from to)
        (move (-1+ n) spare to from))))
~~~

(注：这里的print指的是某一种输出或移动方法。)

在制作这两个空间树的时候就会发现，这两个递归树都是指数树。这就是问题所在：递归树的空间性能十分不好，在问题规模足够大的时候整个树会膨胀的十分严重。

所以希望把算法改进为迭代的方式去求解，这样空间性能就会得到优化，但是时间上未必，因为像汉诺塔，最终都是要一个一个的移动。所以时间性能上只可能会优化系数，但是在复杂度上可能没有变化。

## 练习
### 尝试把斐波那契数列和递归树优化为迭代法

~~~scheme



~~~