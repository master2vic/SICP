# 前言

本门课程的三大主题: 

1. 黑盒抽象

2. 约定接口

3. 元语言抽象

# 开始学习Lisp

## Q 要思考一下问题👇

1. 构成语言的基本元素有哪些?

2. 如何把这些基本元素结合起来?

3. 如何抽象这些基本元素?

## 组合式

( + 3 17.4 6) -> 26.4

其中括号及其包含的就是一个组合式(combination)
一个组合式包含操作符和一组操作对象,其中操作对象也可以是一个组合式.

这里在书中特别的提示了如果出现以下的组合式:
~~~scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
~~~
则应该写为
~~~scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
~~~
来保证良好的阅读体验

### 语法树

![语法树.png](pic\1.1.png)

现在的Lisp用这么奇怪的括号是因为当年的打字方式决定的,而不是括号有多么方便
如果是现在的计算机时代发明的话可能Lisp语言更具有树型结构.

## 抽象方法

如何把底层逻辑抽象出来,方便使用呢?

通过宏定义的方式(define)

例如定义一个square运算符来表示计算平方.
~~~ scheme
(define (square x) (* x x))
~~~
这还有另一种写法:
~~~ scheme
(define square (lambda (x) ( * x x)))
~~~
其中 lambda 就是制作一个过程( make a procedure )其参数为 x , 其返回值为 x*x

以上两种写法在解释器看来没有本质的区别,但是我们程第一种为语法糖.因为第一种写法对于我们更友好.

知道了定义一个运算符之后 ,其实回头看 + 法运算符, 会发现其实在本质上 'square'和 '+'没有太大区别. 因为 + 法其实也是一种抽象,也可以定义为 'add' ,但是当然没有必要这样重复造轮子.

同时这一点也说名了一个事实:**Lisp 语言可以让你无视什么是系统提供的 ,什么是自己定义的.**这是一件好事,因为这样的话你需要不断的define 一些优秀的方法,之后你每一次写代码的时候可以使用更高级的抽象方法, 来快速实现想法.

同时在Lisp中也有条件分支语句 如 : cond (condition的缩写) , if ... 你也可以自己定义一个.观察下面两种写法:
~~~scheme
(define (abs x) 
    (cond ( (< x 0) (- x)))
        ((= x 0) ( 0 ))
        ( (> x 0) (x)))
~~~
~~~scheme
(define (abs x)
    (if (< x 0)
        (- x)
        x ))
~~~
观察在cond符号后面的括号中有一个 **(< x 0)** .这被称为谓词(也可以叫做条件式)他会返回'ture' 或'false'两种真值. 在谓词后面是执行语句,这里是因为 '-'号后只有x一个参数所以就是对x取反.这只是'-'号的特殊性.不需要过度理解.

可以看到if也是cond的语法糖,也可以把cond看作是if的语法糖.

(tip:在运算符中有 and or not 等可以作为结合条件式的运算符)

## 课堂问题

### Q 为什么使用define的时候有的时候第一个带括号有的时候不带呢?
如:
~~~scheme
(define a (* x x))
~~~
和
~~~ scheme
(define (square x) (* x x))
或者其语法糖
(define square (lambda (x) (* x x)))
~~~

**原因**:

因为define 语句的用法:
(define thing thing_to_be)
而其中thing可以是一个表达式,所以你可以定义一个square方法.而括号的有无只说明是否定义了一个过程.


## example
这个例子会显示出Lisp语言的特性,事实证明不需要循环语句就可以做到"连续"

Q : 求一个数的平方根.(使用亚历山大heron连续求平均值法.)

A : 
~~~scheme
(define (square x) (* x x))
(define (average x y) (/ (+ x y) 2))
(define (sqrt x)
    (define (improve guess)
        (average guess (/ x guess)))
    (define (good-enough? guess)
        (< (abs (- (square guess) x)) 
            .00001))
    (define (try guess)
        (if (good-enough? guess)
            guess
            (try (improve guess))))
    (try 1))
~~~

这是一种递归定义,这里最有意思的一点就是这个递归调用可以实现自己解释自己,自己定义自己的过程.看上去不可思议,但是事实就是如此.

我们来看一下这个代码的语法树:

![sqrt.png](pic\sqrt.png)

看到了吗? try是内部定义,但用是自己调用的函数. 在学习其他语言的时候也会涉及到递归这种思想, 递归其实是一种很好的设计方式.

## 小结回顾

还记得最一开始的三个问题吗?为了回答这三个问题.我们看以下表格.

|  基本元素    |   运算符     |  数据    |
| ---- | ---- | ---- |
|  如何结合元素    |用运算符和运算对象组合的函数,组合式,define,if...      |      |
|  如何抽象    | 使用define     |      |
在后面的学习中会学习数据的结合和抽象
## 在那门课中的提问
### Q1 : 一下两种表达有什么不同

~~~ scheme
(define a (* 5 5))
(define (d) (* 5 5))
~~~
在使用a和d的时候结果是相同的,但是本质上有什么区别.
