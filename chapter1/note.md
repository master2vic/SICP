# 前言

本门课程的三大主题: 

1. 黑盒抽象

2. 约定接口

3. 元语言抽象

# 开始学习Lisp

## Q 要思考一下问题👇

1. 构成语言的基本元素有哪些?

2. 如何把这些基本元素结合起来?

3. 如何抽象这些基本元素?

## 组合式

( + 3 17.4 6) -> 26.4

其中括号及其包含的就是一个组合式(combination)
一个组合式包含操作符和一组操作对象,其中操作对象也可以是一个组合式.

这里在书中特别的提示了如果出现以下的组合式:
~~~scheme
(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
~~~
则应该写为
~~~scheme
(+ (* 3
      (+ (* 2 4)
         (+ 3 5)))
   (+ (- 10 7)
      6))
~~~
来保证良好的阅读体验

### 语法树

![语法树.png](pic\1.1.png)

现在的Lisp用这么奇怪的括号是因为当年的打字方式决定的,而不是括号有多么方便
如果是现在的计算机时代发明的话可能Lisp语言更具有树型结构.

## 抽象方法

如何把底层逻辑抽象出来,方便使用呢?

通过宏定义的方式(define)

例如定义一个square运算符来表示计算平方.
~~~ scheme
(define (square x) (* x x))
~~~
这还有另一种写法:
~~~ scheme
(define square (lambda (x) ( * x x)))
~~~
其中 lambda 就是制作一个过程( make a procedure )其参数为 x , 其返回值为 x*x

以上两种写法在解释器看来没有本质的区别,但是我们程第一种为语法糖.因为第一种写法对于我们更友好.

知道了定义一个运算符之后 ,其实回头看 + 法运算符, 会发现其实在本质上 'square'和 '+'没有太大区别. 因为 + 法其实也是一种抽象,也可以定义为 'add' ,但是当然没有必要这样重复造轮子.

同时这一点也说名了一个事实:**Lisp 语言可以让你无视什么是系统提供的 ,什么是自己定义的.**这是一件好事,因为这样的话你需要不断的define 一些优秀的方法,之后你每一次写代码的时候可以使用更高级的抽象方法, 来快速实现想法.

<<<<<<< Updated upstream
=======
同时在Lisp中也有条件分支语句 如 : cond (condition的缩写) , if ... 你也可以自己定义一个.观察下面两种写法:
~~~scheme
(define (abs x) 
    (cond ( (< x 0) (- x)))
        ((= x 0) ( 0 ))
        ( (> x 0) (x)))
~~~
~~~scheme
(define (abs x)
    (if (< x 0)
        (- x)
        x ))
~~~
观察在cond符号后面的括号中有一个 **(< x 0)** .这被称为谓词(也可以叫做条件式)他会返回'ture' 或'false'两种真值. 在谓词后面是执行语句,这里是因为 '-'号后只有x一个参数所以就是对x取反.这只是'-'号的特殊性.不需要过度理解.

可以看到if也是cond的语法糖.
>>>>>>> Stashed changes
